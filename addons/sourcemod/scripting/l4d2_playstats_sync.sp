#include <ripext>
#include <regex>
#include <sourcemod>
#include <left4dhooks>
#include <readyup>

#define NEEDED_FOR_THE_MIX 2
#define L4D2_TEAM_SPECTATOR 1
#define L4D2_TEAM_SURVIVOR 2
#define L4D2_TEAM_INFECTED 3

public Plugin myinfo =
{
	name		= "L4D2 - Player Statistics Sync",
	author		= "Altair Sossai",
	description = "Sends the information generated by plugin l4d2_playstats.smx to the API of l4d2_playstats",
	version		= "1.0.0",
	url			= "https://github.com/altair-sossai/l4d2-zone-server"
};

ConVar cvar_playstats_endpoint;
ConVar cvar_playstats_access_token;
ConVar cvar_playstats_web_url;

int mixVotes = 0;
bool mixBlocked = false;

public void OnPluginStart()
{
	cvar_playstats_endpoint = CreateConVar("playstats_endpoint", "https://l4d2-playstats-api.azurewebsites.net", "Play Stats endpoint", FCVAR_PROTECTED);
	cvar_playstats_access_token = CreateConVar("playstats_access_token", "", "Play Stats Access Token", FCVAR_PROTECTED);
	cvar_playstats_web_url = CreateConVar("playstats_web_url", "http://104.234.63.254:5000", "Play Stats web URL", FCVAR_PROTECTED);

	RegAdminCmd("sm_syncstats", SyncStatsCmd, ADMFLAG_BAN);
	RegConsoleCmd("sm_ranking", ShowRankingCmd);
	RegConsoleCmd("sm_lastmatch", LastMatchCmd);
	RegConsoleCmd("sm_rmix", RankingMixCmd);
	RegConsoleCmd("sm_localhost", LocalHostCmd);

	HookEvent("round_start", RoundStart_Event, EventHookMode_PostNoCopy);

	CreateTimer(200.0, DisplayStatsUrlTick, _, TIMER_REPEAT);
}

public void OnRoundIsLive()
{
	BlockMixVotes();
}

public void OnMapStart()
{
	ClearMixVotes();
}

public void OnClientPutInServer(int client)
{
	CreateTimer(60.0, ShowRankingTick, client);
}

Action SyncStatsCmd(int client, int args)
{
	Sync();
	return Plugin_Handled;
}

Action ShowRankingCmd(int client, int args)
{
	ShowRanking(client);
	return Plugin_Handled;
}

Action LastMatchCmd(int client, int args)
{
	LastMatch(client);
	return Plugin_Handled;
}

Action RankingMixCmd(int client, int args)
{
	RankingMix(client);
	return Plugin_Handled;
}

Action LocalHostCmd(int client, int args)
{
	ShowMOTDPanel(client, "localhost", "http://localhost:5000", MOTDPANEL_TYPE_URL);
	return Plugin_Handled;
}

void RoundStart_Event(Event hEvent, const char[] eName, bool dontBroadcast)
{
	ClearMixVotes();
	Sync();
}

Action DisplayStatsUrlTick(Handle timer)
{
	if (!IsInReady() || GameInProgress())
		return Plugin_Continue;

	PrintToChatAll("\x03l4d2.com.br");
	PrintToChatAll("\x04!ranking \x01to check your position");
	PrintToChatAll("\x04!lastmatch \x01to see last match details");

	return Plugin_Continue;
}

Action ShowRankingTick(Handle timer, int client)
{
	if (!IsInReady() || GameInProgress())
		return Plugin_Continue;

	ShowRanking(client);

	return Plugin_Handled;
}

void Sync()
{
	char logsPath[128] = "logs/";
	BuildPath(Path_SM, logsPath, PLATFORM_MAX_PATH, logsPath);

	Regex regex = new Regex("^\\w{4}-\\w{2}-\\w{2}_\\w{2}-\\w{2}_\\d{4}.*\\.txt$");
	DirectoryListing directoryListing = OpenDirectory(logsPath);

	char fileName[128];
	while (directoryListing.GetNext(fileName, sizeof(fileName))) 
	{
		if (!regex.Match(fileName))
			continue;

		SyncFile(fileName);
	}
}

void SyncFile(String:fileName[])
{
	char filePath[128];
	FormatEx(filePath, sizeof(filePath), "%s%s", "logs/", fileName);
	BuildPath(Path_SM, filePath, PLATFORM_MAX_PATH, filePath);

	File file = OpenFile(filePath, "r");
	if (!file)
		return;

	char content[40000];
	file.ReadString(content, sizeof(content), -1);

	JSONObject command = new JSONObject();

	command.SetString("fileName", fileName);
	command.SetString("content", content);

	HTTPRequest request = BuildHTTPRequest("/api/statistics");
	request.Post(command, SyncFileResponse);
}

void SyncFileResponse(HTTPResponse httpResponse, any value)
{
	if (httpResponse.Status != HTTPStatus_OK)
		return;

	ClearCache();

	JSONObject response = view_as<JSONObject>(httpResponse.Data);

	bool mustBeDeleted = response.GetBool("mustBeDeleted");
	if (!mustBeDeleted)
		return;

	char fileName[128];
	response.GetString("fileName", fileName, sizeof(fileName));

	char filePath[128];
	FormatEx(filePath, sizeof(filePath), "%s%s", "logs/", fileName);
	BuildPath(Path_SM, filePath, PLATFORM_MAX_PATH, filePath);

	DeleteFile(filePath);
}

void ClearCache()
{
	new String:web_url[100];
	GetConVarString(cvar_playstats_web_url, web_url, sizeof(web_url));

	char endpoint[128];
	FormatEx(endpoint, sizeof(endpoint), "%s/api/cache/clear", web_url);

	HTTPRequest request = new HTTPRequest(endpoint);
	JSONObject command = new JSONObject();

	request.Post(command, ClearCacheResponse);
}

void ClearCacheResponse(HTTPResponse httpResponse, any value)
{
}

void ShowRanking(int client)
{
	new String:web_url[100];
	GetConVarString(cvar_playstats_web_url, web_url, sizeof(web_url));

	char path[128];
	FormatEx(path, sizeof(path), "%s/ranking", web_url);

	ShowMOTDPanel(client, "L4D2 | Players Ranking", path, MOTDPANEL_TYPE_URL);
}

void LastMatch(int client)
{
	new String:web_url[100];
	GetConVarString(cvar_playstats_web_url, web_url, sizeof(web_url));

	char path[128];
	FormatEx(path, sizeof(path), "%s/last-matches", web_url);

	ShowMOTDPanel(client, "Last match result", path, MOTDPANEL_TYPE_URL);
}

void RankingMix(int client)
{
	if (mixBlocked || !SurvivorOrInfected(client) || GameInProgress())
		return;

	if (NumberOfPlayersInTeams() != 8)
	{
		PrintToChat(client, "\x01You need \x048 players \x01to start the mix");
		return;
	}

	mixVotes++;

	if (!CanRunMix(client))
	{
		PrintToChatAll("\x03%N \x01wants to start a ranking-based mix, type \x04!rmix \x01 to start", client);
		return;
	}

	ClearMixVotes();
	PrintToChatAll("\x01Starting ranking-based mix...");

	JSONObject command = new JSONObject();

	int player = 1
	for (int iClient = 1; iClient <= MaxClients; iClient++)
	{
		if (!IsClientInGame(iClient) || IsFakeClient(iClient) || !SurvivorOrInfected(iClient))
			continue;

		char property[8];
		FormatEx(property, sizeof(property), "player%d", player++);

		new String:communityId[25];
		GetClientAuthId(iClient, AuthId_SteamID64, communityId, sizeof(communityId));

		command.SetString(property, communityId);
	}

	HTTPRequest request = BuildHTTPRequest("/api/mix");
	request.Post(command, RankingMixResponse);
}

void RankingMixResponse(HTTPResponse httpResponse, int any)
{
	if (httpResponse.Status == HTTPStatus_BadRequest)
	{
		JSONObject response = view_as<JSONObject>(httpResponse.Data);
		
		new String:message[256];
		response.GetString("message", message, sizeof(message));

		PrintToChatAll("\x04Error: \x01%s", message);
		return;
	}

	if (httpResponse.Status != HTTPStatus_OK)
	{
		PrintToChatAll("\x04Error generating the mix");
		return;
	}

	MoveAllPlayersToSpectated();

	JSONObject response = view_as<JSONObject>(httpResponse.Data);
	JSONArray survivors = view_as<JSONArray>(response.Get("survivors"));
	JSONArray infecteds = view_as<JSONArray>(response.Get("infecteds"));

	for (int client = 1; client <= MaxClients; client++)
	{
		if (!IsClientInGame(client) || IsFakeClient(client))
			continue;

		new String:clientCommunityId[25];
		GetClientAuthId(client, AuthId_SteamID64, clientCommunityId, sizeof(clientCommunityId));

		bool found = false;

		for (int i = 0; !found && i < survivors.Length; i++)
		{
			JSONObject survivor = view_as<JSONObject>(survivors.Get(i));

			new String:communityId[25];
			survivor.GetString("communityId", communityId, sizeof(communityId));

			if(!StrEqual(communityId, clientCommunityId))
				continue;

			MovePlayerToSurvivor(client);
			found = true;
		}

		for (int i = 0; !found && i < infecteds.Length; i++)
		{
			JSONObject infected = view_as<JSONObject>(infecteds.Get(i));

			new String:communityId[25];
			infected.GetString("communityId", communityId, sizeof(communityId));

			if(!StrEqual(communityId, clientCommunityId))
				continue;

			MovePlayerToInfected(client);
			found = true;
		}
	}

	char survivorTeam[256];

	for (int i = 0; i < survivors.Length; i++)
	{
		JSONObject survivor = view_as<JSONObject>(survivors.Get(i));

		int position = survivor.GetInt("position");

		char name[256];
		survivor.GetString("name", name, sizeof(name));

		if(strlen(survivorTeam) == 0)
			FormatEx(survivorTeam, sizeof(survivorTeam), "\x04#%d \x01%s", position, name);
		else
			FormatEx(survivorTeam, sizeof(survivorTeam), "%s \x03| \x04#%d \x01%s", survivorTeam, position, name);
	}

	char infectedTeam[256];

	for (int i = 0; i < infecteds.Length; i++)
	{
		JSONObject infected = view_as<JSONObject>(infecteds.Get(i));

		int position = infected.GetInt("position");

		char name[256];
		infected.GetString("name", name, sizeof(name));

		if(strlen(infectedTeam) == 0)
			FormatEx(infectedTeam, sizeof(infectedTeam), "\x04#%d \x01%s", position, name);
		else
			FormatEx(infectedTeam, sizeof(infectedTeam), "%s \x03| \x04#%d \x01%s", infectedTeam, position, name);
	}

	PrintToChatAll(survivorTeam);
	PrintToChatAll("\x04---VS---");
	PrintToChatAll(infectedTeam);
}

void MoveAllPlayersToSpectated()
{
	for (int client = 1; client <= MaxClients; client++)
	{
		if (!IsClientInGame(client) || IsFakeClient(client) || !SurvivorOrInfected(client))
			continue;

		MovePlayerToSpectator(client);
	}
}

void MovePlayerToSpectator(int client)
{
	ChangeClientTeam(client, L4D2_TEAM_SPECTATOR);
}

void MovePlayerToSurvivor(int client)
{
	int bot = FindSurvivorBot();
	if (bot <= 0)
		return;

	int flags = GetCommandFlags("sb_takecontrol");
	SetCommandFlags("sb_takecontrol", flags & ~FCVAR_CHEAT);
	FakeClientCommand(client, "sb_takecontrol");
	SetCommandFlags("sb_takecontrol", flags);
}

void MovePlayerToInfected(int client)
{
	ChangeClientTeam(client, L4D2_TEAM_INFECTED);
}

int FindSurvivorBot()
{
	for (int client = 1; client <= MaxClients; client++)
		if(IsClientInGame(client) && IsFakeClient(client) && GetClientTeam(client) == L4D2_TEAM_SURVIVOR)
			return client;

	return -1;
}

bool SurvivorOrInfected(int client)
{
	int clientTeam = GetClientTeam(client);
	
	return clientTeam == L4D2_TEAM_SURVIVOR || clientTeam == L4D2_TEAM_INFECTED;
}

bool GameInProgress()
{
	int teamAScore = L4D2Direct_GetVSCampaignScore(0);
	int teamBScore = L4D2Direct_GetVSCampaignScore(1);
	
	return teamAScore != 0 || teamBScore != 0;
}

int NumberOfPlayersInTeams()
{
	int count = 0;
		
	for (int client = 1; client <= MaxClients; client++)
	{
		if (!IsClientInGame(client) || IsFakeClient(client) || !SurvivorOrInfected(client))
			continue;

		count++;
	}

	return count;
}

bool CanRunMix(int client)
{
	bool admin = GetAdminFlag(GetUserAdmin(client), Admin_Changemap);
	if (admin)
		return true;

	return mixVotes >= NEEDED_FOR_THE_MIX;
}

void ClearMixVotes()
{
	mixVotes = 0;
	mixBlocked = false;
}

void BlockMixVotes()
{
	mixVotes = 0;
	mixBlocked = true;
}

HTTPRequest BuildHTTPRequest(char[] path)
{
	new String:endpoint[255];
	GetConVarString(cvar_playstats_endpoint, endpoint, sizeof(endpoint));
	StrCat(endpoint, sizeof(endpoint), path);

	new String:access_token[100];
	GetConVarString(cvar_playstats_access_token, access_token, sizeof(access_token));

	HTTPRequest request = new HTTPRequest(endpoint);
	request.SetHeader("Authorization", access_token);

	return request;
}