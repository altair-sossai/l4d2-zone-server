#pragma semicolon 1
#pragma newdecls required

#include <ripext>
#include <regex>
#include <sourcemod>
#include <left4dhooks>
#include <readyup>

#define NEEDED_FOR_THE_MIX 2
#define L4D2_TEAM_SPECTATOR 1
#define L4D2_TEAM_SURVIVOR 2
#define L4D2_TEAM_INFECTED 3

#define ICON_ORIGIN_SURVIVOR {0.0, 0.0, 20.0}
#define ICON_ORIGIN_INFECTED {0.0, 0.0, 95.0}

public Plugin myinfo =
{
    name        = "L4D2 - Player Statistics Sync",
    author      = "Altair Sossai",
    description = "Sends the information generated by plugin l4d2_playstats.smx to the API of l4d2_playstats",
    version     = "1.0.0",
    url         = "https://github.com/altair-sossai/l4d2-zone-server"
};

ConVar
    hEndPoint,
    hAccessToken,
    hWebSiteUrl,
    hLocalHostUrl,
    hPatentIconVersion,
    hMaxPatentLevel;

int mixVotes = 0;
bool mixBlocked = false;

int patentIconRef[MAXPLAYERS + 1] = { -1, ... };
int playersLevel[MAXPLAYERS + 1] = { 0, ... };
bool rankingDisplayed[MAXPLAYERS + 1] = { false, ... };

StringMap PlayersPatent;

public void OnPluginStart()
{
    hEndPoint = CreateConVar("playstats_endpoint", "", "Play Stats endpoint", FCVAR_PROTECTED);
    hAccessToken = CreateConVar("playstats_access_token", "", "Play Stats Access Token", FCVAR_PROTECTED);
    hWebSiteUrl = CreateConVar("playstats_web_url", "", "Play Stats web URL", FCVAR_PROTECTED);
    hLocalHostUrl = CreateConVar("playstats_localhost_url", "", "URL used to perform local tests", FCVAR_PROTECTED);
    hPatentIconVersion = CreateConVar("playstats_patent_icon_version", "1", "Version of the patent icon", FCVAR_PROTECTED);
    hMaxPatentLevel = CreateConVar("playstats_max_patent_level", "15", "Max level of the patent", FCVAR_PROTECTED);

    PlayersPatent = new StringMap();

    RegAdminCmd("sm_syncstats", SyncStatsCmd, ADMFLAG_BAN);
    RegConsoleCmd("sm_ranking", ShowRankingCmd);
    RegConsoleCmd("sm_lastmatch", LastMatchCmd);
    RegConsoleCmd("sm_rmix", RankingMixCmd);
    RegConsoleCmd("sm_localhost", LocalHostCmd);

    HookEvent("round_start", RoundStart_Event, EventHookMode_PostNoCopy);
    HookEvent("player_team", PlayerTeam_Event, EventHookMode_Post);

    CreateTimer(200.0, DisplayStatsUrlTick, _, TIMER_REPEAT);
    CreateTimer(1.0, PatentIconTick, _, TIMER_REPEAT);
}

public void OnRoundIsLive()
{
    BlockMixVotes();
    RemoveAllPatentIcons();
    ResetRankingDisplayed();
}

public void OnMapStart()
{
    ClearMixVotes();
    PrecacheAllPatentFiles();
    RefreshPlayersPatent();
}

public void OnClientPutInServer(int client)
{
    CreateTimer(60.0, ShowRankingTick, client);
    RefreshPlayersLevel();
}

public void OnClientDisconnect(int client)
{
    RemovePatentIcon(client);
    RefreshPlayersLevel();
}

Action SyncStatsCmd(int client, int args)
{
    Sync();
    return Plugin_Handled;
}

Action ShowRankingCmd(int client, int args)
{
    ShowRanking(client);
    return Plugin_Handled;
}

Action LastMatchCmd(int client, int args)
{
    LastMatch(client);
    return Plugin_Handled;
}

Action RankingMixCmd(int client, int args)
{
    RankingMix(client);
    return Plugin_Handled;
}

Action LocalHostCmd(int client, int args)
{
    char localHostUrl[100];
    GetConVarString(hLocalHostUrl, localHostUrl, sizeof(localHostUrl));

    ShowMOTDPanel(client, "localhost", localHostUrl, MOTDPANEL_TYPE_URL);
    return Plugin_Handled;
}

void RoundStart_Event(Event hEvent, const char[] eName, bool dontBroadcast)
{
    ClearMixVotes();
    Sync();
}

void PlayerTeam_Event(Event event, const char[] name, bool dontBroadcast)
{
    int client = GetClientOfUserId(GetEventInt(event, "userid"));
    RemovePatentIcon(client);
}

Action DisplayStatsUrlTick(Handle timer)
{
    if (!IsInReady() || GameInProgress())
        return Plugin_Continue;

    PrintToChatAll("\x03l4d2.com.br");
    PrintToChatAll("\x04!ranking \x01to check your position");

    return Plugin_Continue;
}

Action ShowRankingTick(Handle timer, int client)
{
    if (rankingDisplayed[client] || !IsInReady() || GameInProgress())
        return Plugin_Continue;

    ShowRanking(client);

    return Plugin_Handled;
}

Action PatentIconTick(Handle timer)
{
    if (!IsInReady() || GameInProgress())
        return Plugin_Continue;

    int entity;
    int team;

    for (int i = 1; i <= MaxClients; i++)
    {
        if (!IsClientInGame(i) || IsFakeClient(i) || playersLevel[i] == 0)
        {
            RemovePatentIcon(i);
            continue;
        }

        team = GetClientTeam(i);
        if (team != L4D2_TEAM_SURVIVOR && team != L4D2_TEAM_INFECTED)
        {
            RemovePatentIcon(i);
            continue;
        }

        entity = EntRefToEntIndex(patentIconRef[i]);
        if (entity <= MaxClients || !IsValidEntity(entity))
            SetPatentIcon(i);
    }

    return Plugin_Continue;
}

void SetPatentIcon(int client)
{
    int entity = CreateEntityByName("env_sprite");
    if (entity <= MaxClients)
        return;

    patentIconRef[client] = EntIndexToEntRef(entity);

    char fileVMT[64];

    Format(fileVMT, sizeof(fileVMT), "materials/sprites/patent_%02d_v%02d.vmt", playersLevel[client], hPatentIconVersion.IntValue);

    DispatchKeyValue(entity, "model", fileVMT);
    DispatchKeyValueFloat(entity, "scale", 0.001);
    DispatchSpawn(entity);

    SetEntProp(entity, Prop_Send, "m_nSolidType", 0);
    SetEntProp(entity, Prop_Send, "m_usSolidFlags", 4);
    SetEntProp(entity, Prop_Send, "m_CollisionGroup", 0);
    AcceptEntityInput(entity, "DisableCollision");

    SetEntityRenderMode(entity, RENDER_WORLDGLOW);

    SetVariantString("!activator");
    AcceptEntityInput(entity, "SetParent", client);
    SetVariantString("eyes");
    AcceptEntityInput(entity, "SetParentAttachment");
    
    float origin[3];
    
    if (GetClientTeam(client) == L4D2_TEAM_SURVIVOR)
        origin = ICON_ORIGIN_SURVIVOR;
    else
        origin = ICON_ORIGIN_INFECTED;

    TeleportEntity(entity, origin, NULL_VECTOR, NULL_VECTOR);

    SDKUnhook(entity, SDKHook_SetTransmit, OnSetIconTransmit);
    SDKHook(entity, SDKHook_SetTransmit, OnSetIconTransmit);
}

Action OnSetIconTransmit(int entity, int client)
{
    if (GetClientTeam(client) == L4D2_TEAM_SURVIVOR)
    {
        int ref = EntIndexToEntRef(entity);
        
        for (int i = 1; i <= MaxClients; i++)
            if (patentIconRef[i] == ref && GetClientTeam(i) != L4D2_TEAM_SURVIVOR)
                return Plugin_Handled;
    }

    return Plugin_Continue;
}

void Sync()
{
    char logsPath[128] = "logs/";
    BuildPath(Path_SM, logsPath, PLATFORM_MAX_PATH, logsPath);

    Regex regex = new Regex("^\\w{4}-\\w{2}-\\w{2}_\\w{2}-\\w{2}_\\d{4}.*\\.txt$");
    DirectoryListing directoryListing = OpenDirectory(logsPath);

    char fileName[128];
    while (directoryListing.GetNext(fileName, sizeof(fileName))) 
    {
        if (!regex.Match(fileName))
            continue;

        SyncFile(fileName);
    }
}

void SyncFile(char[] fileName)
{
    char filePath[128];
    FormatEx(filePath, sizeof(filePath), "%s%s", "logs/", fileName);
    BuildPath(Path_SM, filePath, PLATFORM_MAX_PATH, filePath);

    File file = OpenFile(filePath, "r");
    if (!file)
        return;

    char content[40000];
    file.ReadString(content, sizeof(content), -1);

    JSONObject command = new JSONObject();

    command.SetString("fileName", fileName);
    command.SetString("content", content);

    HTTPRequest request = BuildHTTPRequest("/api/statistics");
    request.Post(command, SyncFileResponse);
}

void SyncFileResponse(HTTPResponse httpResponse, any value)
{
    if (httpResponse.Status != HTTPStatus_OK)
        return;

    ClearCache();

    JSONObject response = view_as<JSONObject>(httpResponse.Data);

    bool mustBeDeleted = response.GetBool("mustBeDeleted");
    if (!mustBeDeleted)
        return;

    char fileName[128];
    response.GetString("fileName", fileName, sizeof(fileName));

    char filePath[128];
    FormatEx(filePath, sizeof(filePath), "%s%s", "logs/", fileName);
    BuildPath(Path_SM, filePath, PLATFORM_MAX_PATH, filePath);

    DeleteFile(filePath);
}

void ClearCache()
{
    char webSiteUrl[100];
    GetConVarString(hWebSiteUrl, webSiteUrl, sizeof(webSiteUrl));

    char endpoint[128];
    FormatEx(endpoint, sizeof(endpoint), "%s/api/cache/clear", webSiteUrl);

    HTTPRequest request = new HTTPRequest(endpoint);
    JSONObject command = new JSONObject();

    request.Post(command, ClearCacheResponse);
}

void ClearCacheResponse(HTTPResponse httpResponse, any value)
{
    if (httpResponse.Status != HTTPStatus_OK)
        return;

    RefreshPlayersPatent();
}

void RefreshPlayersPatent()
{
    char webSiteUrl[100];
    GetConVarString(hWebSiteUrl, webSiteUrl, sizeof(webSiteUrl));

    char endpoint[128];
    FormatEx(endpoint, sizeof(endpoint), "%s/api/players/patents", webSiteUrl);

    HTTPRequest request = new HTTPRequest(endpoint);

    request.Get(RefreshPlayersPatentResponse);
}

void RefreshPlayersPatentResponse(HTTPResponse httpResponse, any value)
{
    if (httpResponse.Status != HTTPStatus_OK)
        return;

    PlayersPatent.Clear();

    JSONArray response = view_as<JSONArray>(httpResponse.Data);

    for (int i = 0; i < response.Length; i++)
    {
        JSONObject player = view_as<JSONObject>(response.Get(i));

        char communityId[25];
        player.GetString("communityId", communityId, sizeof(communityId));

        int level = player.GetInt("level");

        PlayersPatent.SetValue(communityId, level, true);
    }

    RefreshPlayersLevel();
}

void ShowRanking(int client)
{
    rankingDisplayed[client] = true;

    char webSiteUrl[100];
    GetConVarString(hWebSiteUrl, webSiteUrl, sizeof(webSiteUrl));

    char path[128];
    FormatEx(path, sizeof(path), "%s/ranking", webSiteUrl);

    ShowMOTDPanel(client, "L4D2 | Players Ranking", path, MOTDPANEL_TYPE_URL);
}

void LastMatch(int client)
{
    char webSiteUrl[100];
    GetConVarString(hWebSiteUrl, webSiteUrl, sizeof(webSiteUrl));

    char path[128];
    FormatEx(path, sizeof(path), "%s/last-matches", webSiteUrl);

    ShowMOTDPanel(client, "Last match result", path, MOTDPANEL_TYPE_URL);
}

void RankingMix(int client)
{
    if (mixBlocked || !SurvivorOrInfected(client) || GameInProgress())
        return;

    if (NumberOfPlayersInTeams() != 8)
    {
        PrintToChat(client, "\x01You need \x048 players \x01to start the mix");
        return;
    }

    mixVotes++;

    if (!CanRunMix(client))
    {
        PrintToChatAll("\x03%N \x01wants to start a ranking-based mix, type \x04!rmix \x01 to start", client);
        return;
    }

    ClearMixVotes();
    PrintToChatAll("\x01Starting ranking-based mix...");

    JSONObject command = new JSONObject();

    int player = 1;
    for (int i = 1; i <= MaxClients; i++)
    {
        if (!IsClientInGame(i) || IsFakeClient(i) || !SurvivorOrInfected(i))
            continue;

        char property[8];
        FormatEx(property, sizeof(property), "player%d", player++);

        char communityId[25];
        GetClientAuthId(i, AuthId_SteamID64, communityId, sizeof(communityId));

        command.SetString(property, communityId);
    }

    HTTPRequest request = BuildHTTPRequest("/api/mix");
    request.Post(command, RankingMixResponse);
}

void RankingMixResponse(HTTPResponse httpResponse, int any)
{
    if (httpResponse.Status == HTTPStatus_BadRequest)
    {
        JSONObject response = view_as<JSONObject>(httpResponse.Data);
        
        char message[256];
        response.GetString("message", message, sizeof(message));

        PrintToChatAll("\x04Error: \x01%s", message);
        return;
    }

    if (httpResponse.Status != HTTPStatus_OK)
    {
        PrintToChatAll("\x04Error generating the mix");
        return;
    }

    MoveAllPlayersToSpectated();

    JSONObject response = view_as<JSONObject>(httpResponse.Data);
    JSONArray survivors = view_as<JSONArray>(response.Get("survivors"));
    JSONArray infecteds = view_as<JSONArray>(response.Get("infecteds"));

    for (int client = 1; client <= MaxClients; client++)
    {
        if (!IsClientInGame(client) || IsFakeClient(client))
            continue;

        char clientCommunityId[25];
        GetClientAuthId(client, AuthId_SteamID64, clientCommunityId, sizeof(clientCommunityId));

        bool found = false;

        for (int i = 0; !found && i < survivors.Length; i++)
        {
            JSONObject survivor = view_as<JSONObject>(survivors.Get(i));

            char communityId[25];
            survivor.GetString("communityId", communityId, sizeof(communityId));

            if(!StrEqual(communityId, clientCommunityId))
                continue;

            MovePlayerToSurvivor(client);
            found = true;
        }

        for (int i = 0; !found && i < infecteds.Length; i++)
        {
            JSONObject infected = view_as<JSONObject>(infecteds.Get(i));

            char communityId[25];
            infected.GetString("communityId", communityId, sizeof(communityId));

            if(!StrEqual(communityId, clientCommunityId))
                continue;

            MovePlayerToInfected(client);
            found = true;
        }
    }

    char survivorTeam[256];

    for (int i = 0; i < survivors.Length; i++)
    {
        JSONObject survivor = view_as<JSONObject>(survivors.Get(i));

        int position = survivor.GetInt("position");

        char name[256];
        survivor.GetString("name", name, sizeof(name));

        if(strlen(survivorTeam) == 0)
            FormatEx(survivorTeam, sizeof(survivorTeam), "\x04#%d \x01%s", position, name);
        else
            FormatEx(survivorTeam, sizeof(survivorTeam), "%s \x03| \x04#%d \x01%s", survivorTeam, position, name);
    }

    char infectedTeam[256];

    for (int i = 0; i < infecteds.Length; i++)
    {
        JSONObject infected = view_as<JSONObject>(infecteds.Get(i));

        int position = infected.GetInt("position");

        char name[256];
        infected.GetString("name", name, sizeof(name));

        if(strlen(infectedTeam) == 0)
            FormatEx(infectedTeam, sizeof(infectedTeam), "\x04#%d \x01%s", position, name);
        else
            FormatEx(infectedTeam, sizeof(infectedTeam), "%s \x03| \x04#%d \x01%s", infectedTeam, position, name);
    }

    PrintToChatAll(survivorTeam);
    PrintToChatAll("\x04---VS---");
    PrintToChatAll(infectedTeam);
}

void MoveAllPlayersToSpectated()
{
    for (int client = 1; client <= MaxClients; client++)
    {
        if (!IsClientInGame(client) || IsFakeClient(client) || !SurvivorOrInfected(client))
            continue;

        MovePlayerToSpectator(client);
    }
}

void MovePlayerToSpectator(int client)
{
    ChangeClientTeam(client, L4D2_TEAM_SPECTATOR);
}

void MovePlayerToSurvivor(int client)
{
    int bot = FindSurvivorBot();
    if (bot <= 0)
        return;

    int flags = GetCommandFlags("sb_takecontrol");
    SetCommandFlags("sb_takecontrol", flags & ~FCVAR_CHEAT);
    FakeClientCommand(client, "sb_takecontrol");
    SetCommandFlags("sb_takecontrol", flags);
}

void MovePlayerToInfected(int client)
{
    ChangeClientTeam(client, L4D2_TEAM_INFECTED);
}

int FindSurvivorBot()
{
    for (int client = 1; client <= MaxClients; client++)
        if(IsClientInGame(client) && IsFakeClient(client) && GetClientTeam(client) == L4D2_TEAM_SURVIVOR)
            return client;

    return -1;
}

bool SurvivorOrInfected(int client)
{
    int clientTeam = GetClientTeam(client);
    
    return clientTeam == L4D2_TEAM_SURVIVOR || clientTeam == L4D2_TEAM_INFECTED;
}

bool GameInProgress()
{
    int teamAScore = L4D2Direct_GetVSCampaignScore(0);
    int teamBScore = L4D2Direct_GetVSCampaignScore(1);
    
    return teamAScore != 0 || teamBScore != 0;
}

int NumberOfPlayersInTeams()
{
    int count = 0;
        
    for (int client = 1; client <= MaxClients; client++)
    {
        if (!IsClientInGame(client) || IsFakeClient(client) || !SurvivorOrInfected(client))
            continue;

        count++;
    }

    return count;
}

bool CanRunMix(int client)
{
    bool admin = GetAdminFlag(GetUserAdmin(client), Admin_Changemap);
    if (admin)
        return true;

    return mixVotes >= NEEDED_FOR_THE_MIX;
}

void ClearMixVotes()
{
    mixVotes = 0;
    mixBlocked = false;
}

void BlockMixVotes()
{
    mixVotes = 0;
    mixBlocked = true;
}

void PrecacheAllPatentFiles()
{
    int patentIconVersion = hPatentIconVersion.IntValue;
    int maxPatentLevel = hMaxPatentLevel.IntValue;

    for (int i = 1; i <= maxPatentLevel; i++)
    {
        char fileVMT[64];
        char fileVTF[64];

        Format(fileVMT, sizeof(fileVMT), "materials/sprites/patent_%02d_v%02d.vmt", i, patentIconVersion);
        Format(fileVTF, sizeof(fileVTF), "materials/sprites/patent_%02d_v%02d.vtf", i, patentIconVersion);

        AddFileToDownloadsTable(fileVMT);
        AddFileToDownloadsTable(fileVTF);

        if (!IsModelPrecached(fileVMT))
            PrecacheModel(fileVMT, true);

        if (!IsModelPrecached(fileVTF))
            PrecacheModel(fileVTF, true);
    }
}

void ResetRankingDisplayed()
{
    for (int i = 0; i <= MaxClients; i++)
        rankingDisplayed[i] = false;
}

void RemoveAllPatentIcons()
{
    for (int i = 0; i <= MaxClients; i++)
        RemovePatentIcon(i);
}

void RemovePatentIcon(int client)
{
    int ent = EntRefToEntIndex(patentIconRef[client]);
    if (ent > MaxClients && IsValidEntity(ent))
    {
        SetEntProp(ent, Prop_Data, "m_fEffects", 32);
        RemoveEntity(ent);
    }
    patentIconRef[client] = -1;
}

void RefreshPlayersLevel()
{
    RemoveAllPatentIcons();

    for (int i = 1; i <= MaxClients; i++)
    {
        if (!IsClientInGame(i) || IsFakeClient(i))
        {
            playersLevel[i] = 0;
            continue;
        }

        char communityId[25];
        GetClientAuthId(i, AuthId_SteamID64, communityId, sizeof(communityId));

        int level;
        if (PlayersPatent.GetValue(communityId, level))
            playersLevel[i] = level;
        else
            playersLevel[i] = 0;
    }
}

HTTPRequest BuildHTTPRequest(char[] path)
{
    char endpoint[255];
    GetConVarString(hEndPoint, endpoint, sizeof(endpoint));
    StrCat(endpoint, sizeof(endpoint), path);

    char accessToken[100];
    GetConVarString(hAccessToken, accessToken, sizeof(accessToken));

    HTTPRequest request = new HTTPRequest(endpoint);
    request.SetHeader("Authorization", accessToken);

    return request;
}